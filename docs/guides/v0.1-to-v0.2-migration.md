# v0.1.x to v0.2.0 Migration Guide

This guide provides a complete walkthrough for migrating from Skeleton Crew Runtime v0.1.x to v0.2.0, including code examples, common issues, and best practices.

## Table of Contents

- [Migration Overview](#migration-overview)
- [Breaking Changes](#breaking-changes)
- [Step-by-Step Migration](#step-by-step-migration)
- [Code Examples](#code-examples)
- [Common Migration Issues](#common-migration-issues)
- [Testing Your Migration](#testing-your-migration)
- [Rollback Plan](#rollback-plan)

## Migration Overview

### What's Changing

**v0.2.0 introduces:**
- **Generic Runtime/Context** - Full TypeScript generic support
- **Sync Config Access** - Direct access via `ctx.config`
- **Plugin Dependencies** - Explicit dependency resolution
- **Enhanced Logger** - Logger available on context

### Backward Compatibility

✅ **v0.2.0 is 100% backward compatible** - existing v0.1.x code will continue to work without changes.

### Migration Benefits

- **Type Safety**: Eliminate `as any` casting
- **Better DX**: Full IDE autocomplete and error detection
- **Cleaner Code**: More readable and maintainable
- **Explicit Dependencies**: Clear plugin relationships

## Breaking Changes

**None!** v0.2.0 is fully backward compatible. However, to get the full benefits, you'll want to migrate to the new patterns.

## Step-by-Step Migration

### Step 1: Update Package

```bash
npm install skeleton-crew-runtime@^0.2.0
```

Verify the update:
```bash
npm list skeleton-crew-runtime
# Should show version 0.2.0 or higher
```

### Step 2: Define Configuration Interface

Create a TypeScript interface for your configuration:

```typescript
// Before (v0.1.x) - No types
const config = {
  apiUrl: 'https://api.example.com',
  apiKey: process.env.API_KEY,
  database: {
    url: process.env.DATABASE_URL,
    maxConnections: 10
  },
  features: {
    analytics: true,
    caching: false
  }
};

// After (v0.2.0) - Typed interface
interface AppConfig {
  apiUrl: string;
  apiKey: string;
  database: {
    url: string;
    maxConnections: number;
  };
  features: {
    analytics: boolean;
    caching: boolean;
  };
}

const config: AppConfig = {
  apiUrl: 'https://api.example.com',
  apiKey: process.env.API_KEY!,
  database: {
    url: process.env.DATABASE_URL!,
    maxConnections: 10
  },
  features: {
    analytics: true,
    caching: false
  }
};
```

### Step 3: Update Runtime Creation

```typescript
// Before (v0.1.x)
import { Runtime } from 'skeleton-crew-runtime';

const runtime = new Runtime({
  hostContext: {
    config: config,
    // other services...
  }
});

// After (v0.2.0)
import { Runtime } from 'skeleton-crew-runtime';

const runtime = new Runtime<AppConfig>({
  config: config,
  // hostContext still supported for other services
  hostContext: {
    // other services...
  }
});
```

### Step 4: Update Plugin Definitions

```typescript
// Before (v0.1.x)
const myPlugin = {
  name: 'my-plugin',
  version: '1.0.0',
  setup(ctx) {
    const config = (ctx.host.config as any);
    const { apiUrl, apiKey } = config;
    
    ctx.actions.registerAction({
      id: 'api:request',
      handler: async (params) => {
        // No type safety on params
        return await fetch(`${apiUrl}/${params.endpoint}`);
      }
    });
  }
};

// After (v0.2.0)
import { PluginDefinition, RuntimeContext } from 'skeleton-crew-runtime';

interface ApiRequestParams {
  endpoint: string;
  method?: string;
  body?: any;
}

interface ApiResponse {
  data: any;
  status: number;
}

const myPlugin: PluginDefinition<AppConfig> = {
  name: 'my-plugin',
  version: '1.0.0',
  dependencies: [], // Explicit dependencies
  setup(ctx: RuntimeContext<AppConfig>) {
    // ✅ Fully typed config access
    const { apiUrl, apiKey } = ctx.config;
    
    // ✅ Type-safe action registration
    ctx.actions.registerAction<ApiRequestParams, ApiResponse>({
      id: 'api:request',
      handler: async (params, ctx) => {
        const response = await fetch(`${ctx.config.apiUrl}/${params.endpoint}`, {
          method: params.method || 'GET',
          headers: {
            'Authorization': `Bearer ${ctx.config.apiKey}`
          },
          body: params.body ? JSON.stringify(params.body) : undefined
        });
        
        return {
          data: await response.json(),
          status: response.status
        };
      }
    });
  }
};
```

### Step 5: Update Plugin Registration

```typescript
// Before (v0.1.x) - Same
runtime.registerPlugin(myPlugin);
await runtime.initialize();

// After (v0.2.0) - Same, but with dependency resolution
runtime.registerPlugin(myPlugin);
await runtime.initialize(); // Now resolves dependencies automatically
```

### Step 6: Update Action Calls

```typescript
// Before (v0.1.x)
const result = await ctx.actions.runAction('api:request', {
  endpoint: 'users'
});

// After (v0.2.0) - Type-safe calls
const result = await ctx.actions.runAction<ApiRequestParams, ApiResponse>(
  'api:request',
  { endpoint: 'users', method: 'GET' }
);

// result is now typed as ApiResponse
console.log(result.status); // ✅ Type-safe access
```

## Code Examples

### Complete Migration Example: Browser Extension

#### Before (v0.1.x)

```typescript
// background.js
import { Runtime } from 'skeleton-crew-runtime';

const runtime = new Runtime({
  hostContext: {
    config: {
      maxTabs: 100,
      syncInterval: 5000,
      apiEndpoint: 'https://api.example.com'
    },
    chrome: chrome
  }
});

const tabsPlugin = {
  name: 'tabs',
  version: '1.0.0',
  setup(ctx) {
    const config = (ctx.host.config as any);
    const chrome = ctx.host.chrome;
    
    ctx.actions.registerAction({
      id: 'tabs:query',
      handler: async (filter) => {
        return new Promise((resolve) => {
          chrome.tabs.query(filter || {}, resolve);
        });
      }
    });
    
    ctx.actions.registerAction({
      id: 'tabs:close',
      handler: async (params) => {
        const tabId = params.tabId;
        return new Promise((resolve) => {
          chrome.tabs.remove(tabId, resolve);
        });
      }
    });
  }
};

const syncPlugin = {
  name: 'sync',
  version: '1.0.0',
  setup(ctx) {
    const config = (ctx.host.config as any);
    
    setInterval(async () => {
      const tabs = await ctx.actions.runAction('tabs:query');
      // Sync logic
    }, config.syncInterval);
  }
};

runtime.registerPlugin(tabsPlugin);
runtime.registerPlugin(syncPlugin);
await runtime.initialize();
```

#### After (v0.2.0)

```typescript
// background.ts
import { Runtime, PluginDefinition, RuntimeContext } from 'skeleton-crew-runtime';

// ✅ Define typed configuration
interface ExtensionConfig {
  maxTabs: number;
  syncInterval: number;
  apiEndpoint: string;
}

// ✅ Define typed parameters
interface TabQueryFilter {
  active?: boolean;
  currentWindow?: boolean;
  url?: string;
}

interface TabCloseParams {
  tabId: number;
}

const runtime = new Runtime<ExtensionConfig>({
  config: {
    maxTabs: 100,
    syncInterval: 5000,
    apiEndpoint: 'https://api.example.com'
  },
  hostContext: {
    chrome: chrome // Keep chrome in host context
  }
});

// ✅ Fully typed plugin
const tabsPlugin: PluginDefinition<ExtensionConfig> = {
  name: 'tabs',
  version: '1.0.0',
  setup(ctx: RuntimeContext<ExtensionConfig>) {
    const chrome = ctx.host.chrome as typeof chrome;
    
    // ✅ Type-safe action registration
    ctx.actions.registerAction<TabQueryFilter, chrome.tabs.Tab[]>({
      id: 'tabs:query',
      handler: async (filter) => {
        return new Promise((resolve) => {
          chrome.tabs.query(filter || {}, resolve);
        });
      }
    });
    
    ctx.actions.registerAction<TabCloseParams, void>({
      id: 'tabs:close',
      handler: async ({ tabId }) => {
        return new Promise((resolve) => {
          chrome.tabs.remove(tabId, resolve);
        });
      }
    });
    
    // ✅ Use typed config
    ctx.logger.info(`Tabs plugin initialized (max: ${ctx.config.maxTabs})`);
  }
};

const syncPlugin: PluginDefinition<ExtensionConfig> = {
  name: 'sync',
  version: '1.0.0',
  dependencies: ['tabs'], // ✅ Explicit dependency
  setup(ctx: RuntimeContext<ExtensionConfig>) {
    // ✅ Sync config access
    const { syncInterval, apiEndpoint } = ctx.config;
    
    setInterval(async () => {
      try {
        // ✅ Type-safe action call
        const tabs = await ctx.actions.runAction<TabQueryFilter, chrome.tabs.Tab[]>(
          'tabs:query',
          {}
        );
        
        // Sync with typed config
        await fetch(`${apiEndpoint}/sync`, {
          method: 'POST',
          body: JSON.stringify({ tabs: tabs.slice(0, ctx.config.maxTabs) })
        });
        
        ctx.logger.info(`Synced ${tabs.length} tabs`);
      } catch (error) {
        ctx.logger.error('Sync failed:', error);
      }
    }, syncInterval);
  }
};

runtime.registerPlugin(tabsPlugin);
runtime.registerPlugin(syncPlugin);
await runtime.initialize();
```

### Express.js Application Migration

#### Before (v0.1.x)

```typescript
import express from 'express';
import { Runtime } from 'skeleton-crew-runtime';

const app = express();
const runtime = new Runtime({
  hostContext: {
    config: {
      port: 3000,
      dbUrl: process.env.DATABASE_URL,
      jwtSecret: process.env.JWT_SECRET
    },
    express: app
  }
});

const authPlugin = {
  name: 'auth',
  version: '1.0.0',
  setup(ctx) {
    const config = (ctx.host.config as any);
    const app = ctx.host.express;
    
    ctx.actions.registerAction({
      id: 'auth:login',
      handler: async (credentials) => {
        // Auth logic with untyped config
        const token = jwt.sign(credentials, config.jwtSecret);
        return { token };
      }
    });
    
    app.post('/login', async (req, res) => {
      const result = await ctx.actions.runAction('auth:login', req.body);
      res.json(result);
    });
  }
};
```

#### After (v0.2.0)

```typescript
import express from 'express';
import { Runtime, PluginDefinition, RuntimeContext } from 'skeleton-crew-runtime';

interface ServerConfig {
  port: number;
  database: {
    url: string;
    maxConnections: number;
  };
  auth: {
    jwtSecret: string;
    tokenExpiry: string;
  };
}

interface LoginCredentials {
  email: string;
  password: string;
}

interface LoginResult {
  token: string;
  user: {
    id: string;
    email: string;
  };
}

const app = express();
const runtime = new Runtime<ServerConfig>({
  config: {
    port: parseInt(process.env.PORT || '3000'),
    database: {
      url: process.env.DATABASE_URL!,
      maxConnections: 10
    },
    auth: {
      jwtSecret: process.env.JWT_SECRET!,
      tokenExpiry: '24h'
    }
  },
  hostContext: {
    express: app
  }
});

const authPlugin: PluginDefinition<ServerConfig> = {
  name: 'auth',
  version: '1.0.0',
  setup(ctx: RuntimeContext<ServerConfig>) {
    const app = ctx.host.express as express.Application;
    
    // ✅ Type-safe action with typed config access
    ctx.actions.registerAction<LoginCredentials, LoginResult>({
      id: 'auth:login',
      handler: async (credentials, ctx) => {
        // ✅ Typed config access
        const { jwtSecret, tokenExpiry } = ctx.config.auth;
        
        // Auth logic
        const user = await authenticateUser(credentials);
        const token = jwt.sign({ userId: user.id }, jwtSecret, {
          expiresIn: tokenExpiry
        });
        
        return { token, user };
      }
    });
    
    app.post('/login', async (req, res) => {
      try {
        const result = await ctx.actions.runAction<LoginCredentials, LoginResult>(
          'auth:login',
          req.body
        );
        res.json(result);
      } catch (error) {
        res.status(401).json({ error: error.message });
      }
    });
    
    ctx.logger.info(`Auth plugin initialized (JWT expiry: ${ctx.config.auth.tokenExpiry})`);
  }
};

runtime.registerPlugin(authPlugin);
await runtime.initialize();

// ✅ Use typed config for server startup
const { port } = runtime.getConfig();
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
```

## Common Migration Issues

### Issue 1: TypeScript Compilation Errors

**Problem:**
```typescript
// Error: Property 'apiUrl' does not exist on type 'Record<string, unknown>'
const { apiUrl } = ctx.config;
```

**Solution:**
```typescript
// Define proper interface
interface AppConfig {
  apiUrl: string;
}

// Use generic types
const runtime = new Runtime<AppConfig>({ config: { apiUrl: '...' } });
const plugin: PluginDefinition<AppConfig> = { /* ... */ };
```

### Issue 2: Missing Dependencies

**Problem:**
```typescript
// Error: Plugin "api" requires dependency "database" to be initialized first
```

**Solution:**
```typescript
const apiPlugin: PluginDefinition<AppConfig> = {
  name: 'api',
  version: '1.0.0',
  dependencies: ['database'], // ✅ Add explicit dependency
  setup(ctx) { /* ... */ }
};
```

### Issue 3: Host Context vs Config Confusion

**Problem:**
```typescript
// Still using old pattern
const config = (ctx.host.config as any);
```

**Solution:**
```typescript
// Use new direct config access
const { apiUrl, apiKey } = ctx.config;
```

### Issue 4: Stale Config Closures (CRITICAL)

**Problem:**
```typescript
// ❌ Dangerous pattern - creates stale closure
const myPlugin: PluginDefinition<AppConfig> = {
  name: 'my-plugin',
  version: '1.0.0',
  setup(ctx) {
    const config = ctx.config; // ❌ Captures initial config reference
    
    ctx.actions.registerAction({
      id: 'my:action',
      handler: async () => {
        // ❌ Uses stale config - won't see runtime updates
        return await fetch(config.apiUrl);
      }
    });
  }
};
```

**Solution:**
```typescript
// ✅ Safe pattern - always access current config
const myPlugin: PluginDefinition<AppConfig> = {
  name: 'my-plugin',
  version: '1.0.0',
  setup(ctx) {
    ctx.actions.registerAction({
      id: 'my:action',
      handler: async (params, ctx) => {
        // ✅ Always gets current config
        const { apiUrl } = ctx.config;
        return await fetch(apiUrl);
      }
    });
  }
};
```

**Why this happens:**
- `ctx.config` is a getter that returns the current config
- Assigning `const config = ctx.config` captures the current reference
- Runtime config updates create new objects, but your variable keeps the old reference
- This was a critical bug identified in real-world usage

**Rule:** Never assign `ctx.config` to a variable in `setup()`. Always access it directly.

### Issue 5: Action Type Safety

**Problem:**
```typescript
// No type safety on parameters or return values
const result = await ctx.actions.runAction('api:call', params);
```

**Solution:**
```typescript
// Add type parameters
const result = await ctx.actions.runAction<ApiParams, ApiResult>('api:call', params);
```

## Testing Your Migration

### 1. Compilation Test

```bash
# Ensure TypeScript compilation passes
npm run build

# Should complete without errors
```

### 2. Runtime Test

```typescript
// Create test to verify functionality
import { describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('Migration Test', () => {
  let runtime: Runtime<AppConfig>;
  
  beforeEach(async () => {
    runtime = new Runtime<AppConfig>({
      config: {
        apiUrl: 'https://test.example.com',
        apiKey: 'test-key'
      }
    });
    
    runtime.registerPlugin(myPlugin);
    await runtime.initialize();
  });
  
  afterEach(async () => {
    await runtime.shutdown();
  });
  
  it('should have typed config access', () => {
    const ctx = runtime.getContext();
    expect(ctx.config.apiUrl).toBe('https://test.example.com');
    expect(ctx.config.apiKey).toBe('test-key');
  });
  
  it('should execute actions with type safety', async () => {
    const ctx = runtime.getContext();
    const result = await ctx.actions.runAction<ApiRequestParams, ApiResponse>(
      'api:request',
      { endpoint: 'test' }
    );
    
    expect(result).toHaveProperty('data');
    expect(result).toHaveProperty('status');
  });
});
```

### 3. Integration Test

```typescript
// Test that existing functionality still works
describe('Backward Compatibility', () => {
  it('should work with legacy host context', async () => {
    const legacyRuntime = new Runtime({
      hostContext: {
        config: { apiUrl: 'https://legacy.example.com' }
      }
    });
    
    const legacyPlugin = {
      name: 'legacy',
      version: '1.0.0',
      setup(ctx) {
        const config = (ctx.host.config as any);
        expect(config.apiUrl).toBe('https://legacy.example.com');
      }
    };
    
    legacyRuntime.registerPlugin(legacyPlugin);
    await legacyRuntime.initialize();
    await legacyRuntime.shutdown();
  });
});
```

## Rollback Plan

If you encounter issues during migration:

### 1. Quick Rollback

```bash
# Revert to v0.1.x
npm install skeleton-crew-runtime@^0.1.0

# Your existing code should work unchanged
```

### 2. Gradual Migration

```typescript
// Keep both patterns during transition
const runtime = new Runtime<AppConfig>({
  config: newConfig,
  hostContext: {
    config: oldConfig, // Keep for legacy plugins
    // other services
  }
});

// Migrate plugins one at a time
runtime.registerPlugin(newTypedPlugin);
runtime.registerPlugin(oldLegacyPlugin); // Still works
```

### 3. Feature Flags

```typescript
const USE_V2_FEATURES = process.env.USE_V2_FEATURES === 'true';

if (USE_V2_FEATURES) {
  // Use v0.2.0 patterns
  const runtime = new Runtime<AppConfig>({ config });
} else {
  // Use v0.1.x patterns
  const runtime = new Runtime({ hostContext: { config } });
}
```

## Migration Checklist

### Pre-Migration
- [ ] Backup your current codebase
- [ ] Review current plugin architecture
- [ ] Identify configuration structure
- [ ] Plan dependency relationships

### Migration Steps
- [ ] Update to v0.2.0: `npm install skeleton-crew-runtime@^0.2.0`
- [ ] Define TypeScript configuration interface
- [ ] Update Runtime creation (hostContext → config)
- [ ] Update plugin definitions with generic types
- [ ] Add explicit plugin dependencies
- [ ] Replace `ctx.host.config` with `ctx.config`
- [ ] Add type parameters to action calls
- [ ] Remove type casting (`as any`)

### Post-Migration
- [ ] Run TypeScript compilation: `npm run build`
- [ ] Run all tests: `npm test`
- [ ] Test in development environment
- [ ] Verify all functionality works
- [ ] Update documentation
- [ ] Deploy to staging/production

### Validation
- [ ] No TypeScript compilation errors
- [ ] All existing functionality works
- [ ] New type safety features working
- [ ] Plugin dependencies resolve correctly
- [ ] Performance is maintained or improved

## Summary

**Migration Benefits:**
- ✅ **Type Safety**: Eliminate runtime type errors
- ✅ **Better DX**: Full IDE support and autocomplete
- ✅ **Cleaner Code**: More readable and maintainable
- ✅ **Explicit Dependencies**: Clear plugin relationships
- ✅ **Performance**: Sync config access eliminates Promise overhead

**Migration Effort:**
- **Small projects**: 1-2 hours
- **Medium projects**: Half day
- **Large projects**: 1-2 days

**Risk Level:** **Low** - 100% backward compatibility ensures existing code continues working.

For more help, see:
- [API Reference](../api/reference.md)
- [Plugin Dependencies Guide](./plugin-dependencies.md)
- [Sync vs Async Patterns](./sync-async-patterns.md)