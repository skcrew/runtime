# v0.3+ Roadmap: Architecture & API Improvements

Based on real-world usage feedback from the v0.2.1 migration, this document outlines planned improvements for future releases.

## 1. First-Class Logger Documentation & Cleanup

### Current State
- `ctx.logger` exists and works well
- Some users create `core:log` actions unnecessarily
- Documentation doesn't emphasize native logger

### Planned Improvements
- **Enhanced Documentation**: Explicitly document `ctx.logger` as primary logging mechanism
- **Migration Guide**: Show how to replace action-based logging with native logger
- **CorePlugin Evaluation**: Consider deprecating if only wrapping existing logger

### Example
```typescript
// ✅ Recommended (already available)
setup(ctx) {
  ctx.logger.info('Plugin initialized');
}

// ❌ Unnecessary complexity
setup(ctx) {
  ctx.actions.runAction('core:log', { level: 'info', message: 'Plugin initialized' });
}
```

## 2. Typed Plugin Dependencies

### Current State
- Dependency declaration works: `dependencies: ['auth', 'server']`
- Plugin access is loose: actions-based communication
- No type safety for inter-plugin interfaces

### Planned Improvements
- **Typed Plugin Access**: `ctx.plugins.get<AuthPlugin>('auth')`
- **Plugin Interface Export**: Plugins can export typed interfaces
- **Compile-time Safety**: TypeScript validation for plugin dependencies

### Example
```typescript
// Future API concept
interface AuthPlugin {
  getCurrentUser(): User | null;
  login(credentials: Credentials): Promise<User>;
}

// Plugin exports interface
export const authPlugin: PluginDefinition<AuthPlugin> = {
  name: 'auth',
  interface: {
    getCurrentUser: () => currentUser,
    login: async (creds) => { /* ... */ }
  },
  setup(ctx) { /* ... */ }
};

// Consumer plugin with type safety
setup(ctx) {
  const auth = ctx.plugins.get<AuthPlugin>('auth');
  const user = auth.getCurrentUser(); // Typed!
}
```

## 3. Plugin Loading Telemetry Optimization

### Current State
- Multiple "Sorted X plugins" log messages
- Debug noise during plugin discovery
- Unclear final plugin count

### Planned Improvements
- **Consolidated Logging**: Single "Loaded X plugins" message
- **Debug Level Control**: Detailed logs only at debug level
- **Loading Progress**: Optional progress indicators for large plugin sets

### Example
```typescript
// Current (noisy)
// DEBUG: Found 5 plugins in /path/to/plugins
// DEBUG: Sorted 5 plugins by dependencies  
// DEBUG: Found 2 plugins in npm packages
// DEBUG: Sorted 2 plugins by dependencies
// INFO: Loaded 7 plugins via DirectoryPluginLoader

// Improved (clean)
// INFO: Loaded 7 plugins (5 from paths, 2 from packages)
// DEBUG: Plugin loading details: auth->server->app (dependency order)
```

## 4. Plugin Config Validation

### Current State
- `ctx.config` is `Record<string, unknown>` or generic `T`
- No built-in validation for plugin-specific config
- Runtime errors for invalid config

### Planned Improvements
- **Plugin Config Schemas**: Plugins declare their config requirements
- **Validation Integration**: Built-in support for Zod, runtypes, or similar
- **Early Validation**: Config validation during plugin setup

### Example
```typescript
import { z } from 'zod';

const DatabaseConfigSchema = z.object({
  host: z.string(),
  port: z.number().min(1).max(65535),
  database: z.string(),
  ssl: z.boolean().optional()
});

export const databasePlugin: PluginDefinition = {
  name: 'database',
  configSchema: DatabaseConfigSchema, // New property
  setup(ctx) {
    // Config is automatically validated and typed
    const config = ctx.config.database; // Typed as DatabaseConfig
    const connection = createConnection(config);
  }
};
```

## 5. Service Locator Pattern

### Current State
- Inter-plugin communication via actions: `ctx.actions.runAction('auth:login')`
- Flexible but loose coupling
- Hard to refactor action names

### Planned Improvements
- **Service Registration**: Plugins can register typed services
- **Service Discovery**: Type-safe service lookup
- **Interface Contracts**: Compile-time validation of service interfaces

### Example
```typescript
// Service interface
interface AuthService {
  login(credentials: Credentials): Promise<User>;
  logout(): Promise<void>;
  getCurrentUser(): User | null;
}

// Provider plugin
setup(ctx) {
  ctx.services.register<AuthService>('auth', {
    login: async (creds) => { /* ... */ },
    logout: async () => { /* ... */ },
    getCurrentUser: () => currentUser
  });
}

// Consumer plugin
setup(ctx) {
  const auth = ctx.services.get<AuthService>('auth');
  // Fully typed, refactor-safe
}
```

## Implementation Priority

### High Priority (v0.3.0)
1. **Logger Documentation**: Low effort, high impact
2. **Loading Telemetry**: Simple logging improvements
3. **Config Validation**: Foundation for better DX

### Medium Priority (v0.3.x)
4. **Typed Plugin Dependencies**: Requires API design
5. **Service Locator**: More complex, needs careful design

### Design Principles
- **Backward Compatibility**: All improvements must be opt-in
- **Minimal Core**: Keep runtime small, features as plugins where possible
- **TypeScript First**: Leverage compile-time safety
- **Progressive Enhancement**: Existing patterns continue to work

## Feedback Integration

This roadmap is based on real-world usage feedback from:
- ai-extension-preview migration experience
- Developer pain points identified during v0.2.1 testing
- Community suggestions and feature requests

Future updates will incorporate additional feedback and usage patterns.